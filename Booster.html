<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Audio Booster</title>
  <!-- Bootstrap 5.3 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background-color: #0b0f13; }
    .app-card { border-radius: 1rem; overflow: hidden; }
    .meter { height: 12px; }
    .progress { background-color: rgba(255,255,255,.15); }
    .form-range::-webkit-slider-thumb { background: #dc3545; } /* danger */
    .form-range::-moz-range-thumb { background: #dc3545; }
    .kbd { padding:.15rem .4rem; border:1px solid rgba(255,255,255,.25); border-bottom-width:2px; border-radius:.35rem; }
  </style>
</head>
<body class="bg-dark text-light">
  <!-- NAVBAR -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark border-bottom border-danger sticky-top">
    <div class="container">
      <a class="navbar-brand fw-bold text-danger" href="#">Audio Booster</a>
    </div>
  </nav>

  <main class="container my-4">
    <div class="card bg-dark text-light app-card shadow border border-danger-subtle">
      <div class="card-header bg-danger bg-gradient text-light">
        <div class="d-flex align-items-center justify-content-between">
          <h5 class="mb-0">Booster Volume MP3/WAV</h5>
          <span class="badge text-bg-light text-dark">Max 500%</span>
        </div>
      </div>

      <div class="card-body">
        <!-- Controls Row -->
        <div class="row g-3 align-items-center mb-3">
          <div class="col-12 col-lg-4">
            <label for="file" class="form-label">Select Audio</label>
            <input class="form-control form-control" type="file" id="file" accept="audio/*">
          </div>
          <div class="col-12 col-lg-8 d-flex gap-2 mt-2 mt-lg-4">
            <button id="play" class="btn btn-danger" disabled>
              <i class="bi bi-play-fill"></i> Play / Pause
            </button>
            <button id="stop" class="btn btn-outline-light" disabled>Stop</button>
            <button id="download" class="btn btn-outline-danger" disabled>Export (wav)</button>
          </div>
        </div>

        <!-- Gain & Limiter -->
        <div class="row g-3 align-items-center mb-3">
          <div class="col-12 col-md-8">
            <label for="gain" class="form-label">Booster <span class="text-danger">(0–500%)</span> <span id="gainLabel" class="ms-2 badge text-bg-light text-dark">100%</span></label>
            <input id="gain" type="range" class="form-range" min="0" max="5" step="0.01" value="1">
          </div>
          <div class="col-12 col-md-4">
            <div class="form-check form-switch">
              <input class="form-check-input" type="checkbox" id="limiter" checked>
              <label class="form-check-label" for="limiter">Limiter</label>
            </div>
          </div>
        </div>

        <!-- Status & Meter -->
        <div class="mb-2 small text-light-50">Status: <span id="status" class="text-light">Idle</span></div>
        <div class="progress meter mb-3" role="progressbar" aria-label="Peak meter" aria-valuemin="0" aria-valuemax="100">
          <div id="meterFill" class="progress-bar bg-danger" style="width: 0%"></div>
        </div>

        <!-- (Optional) Native controls for quick preview -->
        <div class="bg-light text-dark p-2 rounded">
          <audio id="preview" class="w-100" controls preload="metadata"></audio>
        </div>
      </div>

      <div class="card-footer bg-dark text-light-50 small d-flex flex-wrap gap-2">
        <span>Tips: use limiter if >100%.</span>
        <span>Shortcut: <span class="kbd">Space</span> play/pause, <span class="kbd">↑/↓</span> gain.</span>
      </div>
<br>
     <footer class="mt-auto bg-danger bg-gradient text-white py-3">
    <div class="container d-flex justify-content-center">
      <div class="d-flex gap-3">
        <!-- Tombol Kiri -->
        <a href="index.html" class="btn btn-dark">Back</a>
        </div>
      </div>
    </div>
  </footer> 
    </div>

    
  
  </main>

  <!-- Bootstrap JS (for potential components; not required for audio logic) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">

  <script>
  (function(){
    const fileInput = document.getElementById('file');
    const btnPlay   = document.getElementById('play');
    const btnStop   = document.getElementById('stop');
    const btnDl     = document.getElementById('download');
    const gainSlider= document.getElementById('gain');
    const gainLabel = document.getElementById('gainLabel');
    const limiterCb = document.getElementById('limiter');
    const statusTxt = document.getElementById('status');
    const meterFill = document.getElementById('meterFill');
    const previewEl = document.getElementById('preview');

    let ac;               // AudioContext
    let gainNode;         // GainNode
    let analyser;         // AnalyserNode
    let compressor;       // DynamicsCompressorNode (limiter)
    let src;              // current BufferSource
    let currentBuffer;    // decoded AudioBuffer
    let rafId;            // meter raf

    function ensureAC(){
      if(!ac){ ac = new (window.AudioContext || window.webkitAudioContext)(); }
      return ac;
    }

    function buildGraph(){
      const ctx = ensureAC();
      if(gainNode) gainNode.disconnect();
      if(analyser) analyser.disconnect();
      if(compressor) compressor.disconnect();

      gainNode = ctx.createGain();
      analyser = ctx.createAnalyser();
      analyser.fftSize = 512;

      compressor = ctx.createDynamicsCompressor();
      compressor.threshold.value = -6; // near brickwall
      compressor.knee.value = 0;
      compressor.ratio.value = 20;
      compressor.attack.value = 0.003;
      compressor.release.value = 0.25;

      connectFlow();
      updateGain();
    }

    function connectFlow(){
      if(!ac) return;
      try{ gainNode.disconnect(); }catch{}
      try{ analyser.disconnect(); }catch{}
      try{ compressor.disconnect(); }catch{}

      if(limiterCb.checked){
        gainNode.connect(compressor);
        compressor.connect(analyser);
        analyser.connect(ac.destination);
      } else {
        gainNode.connect(analyser);
        analyser.connect(ac.destination);
      }
    }

    function updateGain(){
      if(!ac || !gainNode) return;
      const v = parseFloat(gainSlider.value);
      gainNode.gain.setTargetAtTime(v, ac.currentTime, 0.01);
      gainLabel.textContent = Math.round(v*100) + '%';
    }

    function stopPlayback(){
      if(src){
        try{ src.stop(); }catch{}
        try{ src.disconnect(); }catch{}
        src = null;
      }
      cancelAnimationFrame(rafId);
    }

    function playBuffer(){
      if(!currentBuffer) return;
      const ctx = ensureAC();
      if(ctx.state === 'suspended') ctx.resume();

      stopPlayback();
      src = ctx.createBufferSource();
      src.buffer = currentBuffer;
      src.connect(gainNode);
      connectFlow();
      src.start(0);
      statusTxt.textContent = 'Play';
      btnPlay.textContent = 'Pause';

      src.onended = () => {
        btnPlay.textContent = 'Play';
        statusTxt.textContent = 'Done';
        cancelAnimationFrame(rafId);
      };

      startMeter();
    }

    function startMeter(){
      const buf = new Uint8Array(analyser.frequencyBinCount);
      const loop = () => {
        analyser.getByteTimeDomainData(buf);
        let peak = 0;
        for(let i=0;i<buf.length;i++){
          const v = Math.abs(buf[i]-128)/128; // 0..1
          if(v>peak) peak=v;
        }
        const pct = Math.min(100, Math.max(0, peak*100));
        meterFill.style.width = pct.toFixed(1)+'%';
        rafId = requestAnimationFrame(loop);
      };
      cancelAnimationFrame(rafId);
      loop();
    }

    async function decodeForOffline(file){
      const arrayBuf = await file.arrayBuffer();
      const ctx = ensureAC();
      return await ctx.decodeAudioData(arrayBuf.slice(0));
    }

    async function exportBoosted(){
      if(!currentBuffer) return;
      const sampleRate = currentBuffer.sampleRate;
      const length = currentBuffer.length;
      const ch = currentBuffer.numberOfChannels;
      const off = new OfflineAudioContext(ch, length, sampleRate);

      const s = off.createBufferSource();
      s.buffer = currentBuffer;
      const g = off.createGain();
      g.gain.value = parseFloat(gainSlider.value);

      if(limiterCb.checked){
        const c = off.createDynamicsCompressor();
        c.threshold.value = -6; c.knee.value = 0; c.ratio.value = 20; c.attack.value = 0.003; c.release.value = 0.25;
        s.connect(g); g.connect(c); c.connect(off.destination);
      } else {
        s.connect(g); g.connect(off.destination);
      }
      s.start(0);
      const rendered = await off.startRendering();
      const blob = encodeWAV(rendered);
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const base = (fileInput.files?.[0]?.name || 'audio').replace(/\.[^.]+$/, '');
      a.download = base + '_boosted.wav';
      a.click();
    }

    function encodeWAV(audioBuffer){
      let numCh = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const samples = audioBuffer.length;
      const chData = [];
      for(let ch=0; ch<numCh; ch++) chData.push(audioBuffer.getChannelData(ch));

      let interleaved;
      if(numCh === 2){
        interleaved = new Float32Array(samples*2);
        let idx=0; for(let i=0;i<samples;i++){ interleaved[idx++] = chData[0][i]; interleaved[idx++] = chData[1][i]; }
      } else if(numCh === 1){
        interleaved = chData[0];
      } else {
        // mixdown first 2 channels
        const L = chData[0]; const R = chData[1] || chData[0];
        interleaved = new Float32Array(samples*2);
        let idx=0; for(let i=0;i<samples;i++){ interleaved[idx++] = L[i]; interleaved[idx++] = R[i]; }
        numCh = 2;
      }

      const bytesPerSample = 2; // 16-bit PCM
      const blockAlign = numCh * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = interleaved.length * bytesPerSample;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      writeStr(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeStr(view, 8, 'WAVE');
      writeStr(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numCh, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeStr(view, 36, 'data');
      view.setUint32(40, dataSize, true);

      floatTo16(view, 44, interleaved);
      return new Blob([view], {type:'audio/wav'});

      function writeStr(dv, off, str){ for(let i=0;i<str.length;i++) dv.setUint8(off+i, str.charCodeAt(i)); }
      function floatTo16(dv, off, input){ let pos=off; for(let i=0;i<input.length;i++){ let s=Math.max(-1, Math.min(1, input[i])); dv.setInt16(pos, s<0 ? s*0x8000 : s*0x7FFF, true); pos+=2; } }
    }

    // EVENTS
    fileInput.addEventListener('change', async ()=>{
      const file = fileInput.files?.[0];
      if(!file) return;
      ensureAC();
      buildGraph();

      // Load to preview element (optional native controls)
      const url = URL.createObjectURL(file);
      previewEl.src = url; previewEl.load();

      // Decode to buffer for boosted playback/export
      currentBuffer = await decodeForOffline(file);

      // Enable controls
      btnPlay.disabled = false; btnStop.disabled = false; btnDl.disabled = false;
      statusTxt.textContent = 'Ready';

      // Auto play the newly selected audio (buffer path)
      playBuffer();
    });

    btnPlay.addEventListener('click', ()=>{
      if(!currentBuffer){ return; }
      if(!ac){ ensureAC(); buildGraph(); }
      if(ac.state === 'suspended') ac.resume();

      // If playing, pause by stopping; pressing again restarts from beginning
      if(src){
        stopPlayback();
        btnPlay.textContent = 'Play';
        statusTxt.textContent = 'Pause';
      } else {
        playBuffer();
      }
    });

    btnStop.addEventListener('click', ()=>{
      stopPlayback();
      statusTxt.textContent = 'Stop';
    });

    gainSlider.addEventListener('input', updateGain);
    limiterCb.addEventListener('change', connectFlow);

    // Shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.code==='Space'){
        e.preventDefault();
        btnPlay.click();
      }
      if(e.key==='ArrowUp' || e.key==='ArrowDown'){
        const step = e.key==='ArrowUp' ? 0.05 : -0.05;
        const next = Math.max(0, Math.min(5, parseFloat(gainSlider.value) + step));
        gainSlider.value = String(next);
        updateGain();
      }
    });

    btnDl.addEventListener('click', ()=>{
      exportBoosted().catch(err=>{
        console.error(err);
        alert('Failed to Export: ' + err.message);
      });
    });
  })();
  </script>

</body>
</html>
